PRINTSTR	MACRO	STR
LEA DX,STR
MOV	AH,09H
INT 21H
ENDM

SCANSTR	MACRO	STR
MOV	AH,0AH
MOV DX,OFFSET STR
INT 21H
ENDM

PRINTC_DL	MACRO
MOV AH,02H
INT 21H
ENDM

FINISH	MACRO
MOV AH,4CH
INT 21H
ENDM

.MODEL SMALL
.DATA
	STR1	DB	'ENTER A STRING',10,13,'$'
	STR2	DB	20 dup('$')
	STRL	DB	'THE LENGTH IS: ','$'
	STRLEN	DB	?
	STRREV	DB	'THE REVERSE OF STRING IS: ','$'	
	STR3	DB	'THE ABOVE STRING IS A PALINDROME',10,13,'$'
	STR4	DB	'THE ABOVE STRING IS NOT A PALINDROME.',10,13,'$'
	NEWLINE	DB	10,13,'$'
.CODE
	MOV AX,@DATA
	MOV DS,AX
	
	LCHECK:				;LCHECK LABEL INCASE USER ENTERS EMPTY STRING
		PRINTSTR STR1			;PRINT MESSAGE 'ENTER A STRING'

		SCANSTR	STR2			;USER ENTERS STRING
	
		PRINTSTR NEWLINE
	
		MOV CL,STR2+1			;STORES THE LENGTH OF STR2 IN CL
	CMP CL,0H
	JE LCHECK
	
	LEA DX,STRLEN
	MOV [STRLEN],CL			;STORES LENGTH IN STRLEN
	
	PRINTSTR STRL
	MOV DL,[STRLEN]			;STORES LENGTH IN DL
	ADD DL,'0'
	PRINTC_DL
	PRINTSTR NEWLINE
		
	PRINTSTR STRREV
	XOR DH,DH
	MOV DL,[STRLEN]
	INC DX				;DX HOLDS INDEX OF LAST CHARACTER
	MOV DI,DX 
	L:
		MOV DL,STR2[DI]		;MOVE CHARACTER FROM STR2 TO DL
		PRINTC_DL
		DEC DI
		CMP	DI,1H
		JNE L
	PRINTSTR NEWLINE

	XOR CL,CL
	MOV CH,[STRLEN]			;STORES LENGTH IN CH
	
	MOV SI,2H			;SET TO 1ST INDEX OF STRING, I.E 2
	XOR DI,DI			;RESET DI TO 0

	XOR AH,AH
	MOV AL,CH			;MOVE LENGTH TO AL
	MOV DI,AX
	INC DI				;DI WILL NOW HOLD INDEX OF LAST CHARACTER
	MOV CL,02H
	DIV CL				;SET AL TO HALF THE LENGTH
	XOR AH,AH
	ADD AL,02			;AL NOW HOLDS INDEX OF CHARACTER THAT IS MID-STRING

	L1:
		MOV DH,STR2[SI]		;MOVE LEFT CHARACTER TO DH
		MOV DL,[STR2+DI]	;MOVE RIGHT CHARACTER(BYTE FROM OTHER END) TO DL
		DEC DI			;INDEX FROM LAST END GOES TO LEFT
		INC SI			;INDEX FROM FIRST END GOES TO RIGHT
		CMP DH,DL
		JNE	NOPE		;IF EVEN A SINGLE CASE UNEQUAL, THEN NOT A PALINDROME
		
	CMP SI,AX			;AX CONTAINS HALF-LENGTH
	JNE	L1
	JMP	YUP			;IF COUNTERS REACH MID-STRING, THEN PALINDROME
	
	NOPE:
		PRINTSTR STR4
		FINISH			;IF UNEQUAL NO BOTHER GOING FORWARD
		
	YUP:
		PRINTSTR STR3
	
	FINISH
END
